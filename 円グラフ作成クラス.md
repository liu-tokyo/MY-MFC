# 円グラフ作成クラス

> http://7ujm.net/C++/PieChart.h.html

```C++
////////////////////////////////////////////////////////////////////////////
//円グラフ作成クラス
//VC6  VC2003 にて作成
//
//ダブルバッファリングでちらつきの無い描画ができます。
//
//使用方法---------------------------------------------------
//このファイルを	"PieChart.h"　として保存します------------
//
//#include "PieChart.h"
//
//ダイアログ上にSTATICコントロール（IDC_STATIC）を貼り付けます。-----------
//
//グローバル変数に近い所に変数を宣言します。---------
//
//PieChart*p;
//PieData Data[10];
//
//初期化--------------------------------------------------------
//
//p=new PieChart(this,IDC_STATIC);
//p->SetColor(RGB(255,200,200),RGB(0,0,255));
//
//値の設定と描画------------------------------------------------
//
//void CDlg::OnButton1() 
//{
//
////1つ目の扇形の設定
//Data[0].startAngle =0;//開始角度
//Data[0].lastAngle =45;//終了角度
//Data[0].color =RGB(255,0,0);//描画色
//Data[0].paintMode = true;//描画モード　斜線:true　塗りつぶし:false
//
////2つ目の扇形の設定
//Data[1].startAngle =45;
//Data[1].lastAngle =90;
//Data[1].color =RGB(255,0,0);
//Data[1].paintMode = false;
//
////3つ目の扇形の設定
//Data[2].startAngle =90;
//Data[2].lastAngle =180;
//Data[2].color =RGB(0,0,255);
//Data[2].paintMode = true;
//
////4つ目の扇形の設定
//Data[3].startAngle =180;
//Data[3].lastAngle =360;
//Data[3].color =RGB(0,0,255);
//Data[3].paintMode = false;
//
//p->SetData(Data,4);//Data:上の値　4:描画する数
//
//p->OnDrow();//描画
//}
//
///////////////////////////////////////////////////////////////////////////////////

#include "math.h"

struct PieData{
	int startAngle;
	int lastAngle;
	COLORREF color;
	bool paintMode;
};

class PieChart{
private:
	CDialog*pDlg;
	CWnd* pWnd;
	COLORREF cBkColor;
	COLORREF cBaseLineColor;
	PieData*pData;
	int DataCount;

	CPoint Trigon(int angle,int x,int y,int r){
		CPoint p;
		const double pi=3.1415926;
		p.x=(int)((double)x+(sin((pi/(double)180)*(double)angle)*(double)r));
		p.y=(int)((double)y-(cos((pi/(double)180)*(double)angle)*(double)r));
		return p;
	}
protected:
	POINT GetSize(void){
		RECT zRect;
		pWnd->GetClientRect( &zRect );
		POINT p;
		p.x=zRect.right - zRect.left;
		p.y=zRect.bottom - zRect.top;
		return p;
	}

	void DrowGraph(CDC*pMDC,int startAngle,int lastAngle,COLORREF color,bool paintMode=true){
		POINT p=GetSize();
		int iHight=p.x;
		int iWidth=p.y;

		CPen Pen;
		CPen *pTmpPen;
		Pen.CreatePen(PS_SOLID,1,RGB(255,0,0));	//ペンの作成
		pTmpPen = pMDC->SelectObject(&Pen);

		CRect rectClient;
		pWnd->GetClientRect(rectClient);
		CPen pen;
		CBrush brush;
		CBrush* pOldBrush;
		CPen* pOldPen;
		pMDC->SetBkMode(TRANSPARENT);//斜線ブラシの背景をバックカラーで塗りつぶす
		if(paintMode){
			brush.CreateHatchBrush(HS_FDIAGONAL, color);
		}else {brush.CreateSolidBrush(color);}

		pen.CreatePen(PS_SOLID | PS_COSMETIC, 1, color);

		pOldPen = pMDC->SelectObject(&pen);
		pOldBrush = pMDC->SelectObject(&brush);

		int centorY=iWidth/2;
		int centorX=iHight/2;
		int r=10000;

		pMDC->Pie(rectClient,Trigon(lastAngle,centorX,centorY,r),Trigon(startAngle,centorX,centorY,r));

		pMDC->SelectObject(pOldPen);
		pMDC->SelectObject(pOldBrush);
		pen.DeleteObject();
		brush.DeleteObject();
		pMDC->SelectObject(pTmpPen);	//ペンを戻す
		Pen.DeleteObject();
	}
public:

	PieChart(CDialog*pDialog,UINT nID){
		pDlg=pDialog;
		pWnd=pDlg->GetDlgItem(nID);
		cBkColor=RGB(255,255,255);
		cBaseLineColor=RGB(0,0,0);
		DataCount=0;
	}
	void SetData(PieData Data[],int count){
		DataCount=count;
		pData=Data;
	}
	void OnDrow(void){
		pWnd->SetRedraw(true);//描画の開始
		POINT p=GetSize();
		int iHight=p.x;
		int iWidth=p.y;
		
		CDC* pDC=pWnd->GetDC();//CDCを取得
		//描画処理
		CBitmap pBitmap;
		CClientDC dcScreen(pDlg);
		pBitmap.CreateCompatibleBitmap(&dcScreen,iHight,iWidth);//ビットマップを作成

		CDC pMDC;
		pMDC.CreateCompatibleDC(pDC);// 窓と同じ属性のメモリー領域を確保して
		//pB.LoadBitmap(IDB_BITMAP1); // IDB_BITMAP1を選択して
		pMDC.SelectObject(&pBitmap);

		//ブラシの作成
		CBrush Brush;
		CBrush *pTmpBrush;
		Brush.CreateSolidBrush(cBkColor);
		pTmpBrush = pMDC.SelectObject(&Brush);

		//ペンの作成
		CPen Pen;
		CPen *pTmpPen;
		Pen.CreatePen(PS_SOLID,1,cBaseLineColor);	//ペンの作成
		pTmpPen = pMDC.SelectObject(&Pen);		//元のペンを一時退避しながら新たなペンの設定

		//bitmapのBackColorの塗りつぶし
		RECT zRect;
		pWnd->GetClientRect(&zRect);
		pMDC.Rectangle(&zRect);

		//グラフの描画
		DrowGraph(&pMDC,0,45,RGB(255,0,0));

		for(int i=0;i<DataCount;i++){
			DrowGraph(&pMDC,pData[i].startAngle,pData[i].lastAngle,pData[i].color,pData[i].paintMode);
		}

		pDC->BitBlt(0, 0,iHight,iWidth,&pMDC,0,0,SRCCOPY); // 確保したメモリー領域にBitmapをコピーしたのち、pDC に表示します。
		
		pMDC.SelectObject(pTmpPen);				//ペンを戻す
		pMDC.SelectObject(pTmpBrush);			//ブラシを戻す
		Pen.DeleteObject();
		Brush.DeleteObject();
		DeleteDC(pMDC);
		DeleteObject(pBitmap);

		pWnd->ReleaseDC(pDC);//CDCを解放（必ず必要
		pWnd->SetRedraw(false);//描画の停止
	}
	void SetColor(COLORREF BkColor,COLORREF BaseLineColor){
		cBkColor=BkColor;
		cBaseLineColor=BaseLineColor;
	}
};
```

